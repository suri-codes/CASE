use chrono::{DateTime, Utc, serde::ts_milliseconds_option::deserialize as ts_milliseconds_option};
use crux_core::{App, Command, render::render};
use crux_http::command::Http;
use facet::Facet;
use serde::{Deserialize, Serialize};
use url::Url;

use crate::sse::ServerSentEvents;

const API_URL: &str = "https://crux-counter.fly.dev";

// ANCHOR: model
/// The data model for the application.
#[derive(Default, Serialize)]
pub struct Model {
    count: Count,
}

/// Example
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Count {
    value: isize,
    #[serde(deserialize_with = "ts_milliseconds_option")]
    updated_at: Option<DateTime<Utc>>,
}
// ANCHOR_END: model

/// The data structure to hold the data structures needed to
/// view the application.
#[derive(Facet, Serialize, Deserialize, Debug, Clone, Default)]
pub struct ViewModel {
    /// Generic text.
    pub text: String,
    /// Whether the text is confirmed server-side or not.
    pub confirmed: bool,
}

#[derive(Facet, Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
#[repr(C)]
/// The various events the application needs to handle.
pub enum Event {
    /// Get data from the server.
    Get,
    /// Increment the count.
    Increment,
    /// Decrement the count.
    Decrement,
    /// To be honest, I don't know what this is about.
    StartWatch,

    // Events local to the core.
    /// Set the thing?
    #[serde(skip)]
    #[facet(skip)]
    Set(#[facet(opaque)] crux_http::Result<crux_http::Response<Count>>),

    /// Update??
    #[serde(skip)]
    #[facet(skip)]
    Update(#[facet(opaque)] Count),
}

// Have to do this so the method generated by `facet_typegen` don't cause
// the `missing_docs` lint.
#[allow(missing_docs)]
mod inner {
    use crate::sse::SseRequest;
    use crux_core::{macros::effect, render::RenderOperation};
    use crux_http::HttpRequest;
    /// The effects that get sent out of the core, which the application
    /// has to deal with.
    #[effect(facet_typegen)]
    #[derive(Debug)]
    pub enum Effect {
        /// Ask the shell to render the `ViewModel`.
        Render(RenderOperation),
        /// HTTP request.
        Http(HttpRequest),
        /// Server sent event thingy, not too important.
        ServerSentEvents(SseRequest),
    }
}

pub use inner::Effect;

#[derive(Default)]
/// The actual core around the application.
pub struct Counter;

impl App for Counter {
    type Model = Model;
    type Event = Event;
    type ViewModel = ViewModel;
    type Effect = Effect;

    fn update(&self, msg: Event, model: &mut Model) -> Command<Effect, Event> {
        match msg {
            Event::Get => Http::get(API_URL)
                .expect_json()
                .build()
                .then_send(Event::Set),
            Event::Set(Ok(mut response)) => {
                let count = response.take_body().unwrap();
                Command::event(Event::Update(count))
            }
            Event::Set(Err(e)) => {
                panic!("Oh no something went wrong: {e:?}");
            }
            Event::Update(count) => {
                model.count = count;
                render()
            }
            Event::Increment => {
                // optimistic update
                model.count = Count {
                    value: model.count.value + 1,
                    updated_at: None,
                };

                let call_api = {
                    let base = Url::parse(API_URL).unwrap();
                    let url = base.join("/inc").unwrap();
                    Http::post(url).expect_json().build().then_send(Event::Set)
                };

                render().and(call_api)
            }
            Event::Decrement => {
                // optimistic update
                model.count = Count {
                    value: model.count.value - 1,
                    updated_at: None,
                };

                let call_api = {
                    let base = Url::parse(API_URL).unwrap();
                    let url = base.join("/dec").unwrap();
                    Http::post(url).expect_json().build().then_send(Event::Set)
                };

                render().and(call_api)
            }
            Event::StartWatch => {
                let base = Url::parse(API_URL).unwrap();
                let url = base.join("/sse").unwrap();
                ServerSentEvents::get(url).then_send(Event::Update)
            }
        }
    }

    fn view(&self, model: &Self::Model) -> Self::ViewModel {
        let suffix = model
            .count
            .updated_at
            .map_or_else(|| " (pending)".to_string(), |d| format!(" ({d})"));

        Self::ViewModel {
            text: model.count.value.to_string() + &suffix,
            confirmed: model.count.updated_at.is_some(),
        }
    }
}

#[cfg(test)]
mod tests {
    use chrono::{TimeZone, Utc};

    use crux_core::{App as _, assert_effect};
    use crux_http::{
        protocol::{HttpRequest, HttpResponse, HttpResult},
        testing::ResponseBuilder,
    };

    use super::{Counter, Event, Model};
    use crate::{
        Count, Effect,
        sse::{SseRequest, SseResponse},
    };

    // ANCHOR: simple_tests
    /// Test that a `Get` event causes the app to fetch the current
    /// counter value from the web API
    #[test]
    fn get_counter() {
        let app = Counter;
        let mut model = Model::default();

        // Send a `Get` event to the app.
        let mut cmd = app.update(Event::Get, &mut model);

        // The app should emit an HTTP request to fetch the counter.
        let (operation, mut request) = cmd.effects().next().unwrap().expect_http().split();

        // And the request should be a GET to the correct URL.
        assert_eq!(
            operation,
            HttpRequest::get("https://crux-counter.fly.dev/").build()
        );

        // Resolve the request with a simulated response from the web API.
        request
            .resolve(HttpResult::Ok(
                HttpResponse::ok()
                    .body(r#"{ "value": 1, "updated_at": 1672531200000 }"#)
                    .build(),
            ))
            .unwrap();

        // The app should emit a `Set` event with the HTTP response.
        let actual = cmd.events().next().unwrap();
        let expected = Event::Set(Ok(ResponseBuilder::ok()
            .body(Count {
                value: 1,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            })
            .build()));
        assert_eq!(actual, expected);

        // Send the `Set` event back to the app.
        let mut cmd = app.update(actual, &mut model);

        // Check in flight that the app has not been updated with the server data.
        let view = app.view(&model);
        assert_eq!(view.text, "0 (pending)");

        // This should generate an `Update` event.
        let event = cmd.events().next().unwrap();
        assert_eq!(
            event,
            Event::Update(Count {
                value: 1,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            })
        );

        // Send the `Update` event back to the app.
        let mut cmd = app.update(event, &mut model);

        // The model should be updated.
        assert_eq!(
            model.count,
            Count {
                value: 1,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            }
        );

        // The app should ask the shell to render.
        assert_effect!(cmd, Effect::Render(_));

        // The view should be updated.
        let view = app.view(&model);
        assert_eq!(view.text, "1 (2023-01-01 00:00:00 UTC)");
        assert!(view.confirmed);
    }
    // ANCHOR_END: simple_tests

    // Test that an `Increment` event causes the app to increment the counter.
    #[test]
    fn increment_counter() {
        let app = Counter;

        // Set up our initial model as though we've previously fetched the counter.
        let mut model = Model {
            count: Count {
                value: 1,
                updated_at: Some(Utc.with_ymd_and_hms(2022, 12, 31, 23, 59, 0).unwrap()),
            },
        };

        // Send an `Increment` event to the app.
        let mut cmd = app.update(Event::Increment, &mut model);

        // The app should ask the shell to render the optimistic update.
        assert_effect!(cmd, Effect::Render(_));

        // And send an HTTP post.
        let mut request = cmd.effects().next().unwrap().expect_http();
        assert_eq!(
            &request.operation,
            &HttpRequest::post("https://crux-counter.fly.dev/inc").build()
        );

        // We are expecting our model to be updated "optimistically" before the
        // HTTP request completes, so the value should have been updated
        // but not the timestamp.
        assert_eq!(
            model.count,
            Count {
                value: 2,
                updated_at: None
            }
        );

        // Resolve the request with a simulated response from the web API.
        request
            .resolve(HttpResult::Ok(
                HttpResponse::ok()
                    .body(r#"{ "value": 2, "updated_at": 1672531200000 }"#)
                    .build(),
            ))
            .unwrap();

        // This should generate a `Set` event.
        let event = cmd.events().next().unwrap();
        assert!(matches!(event, Event::Set(_)));

        // Send the `Set` event back to the app.
        let mut cmd = app.update(event, &mut model);

        // This should generate an `Update` event.
        let event = cmd.events().next().unwrap();
        assert_eq!(
            event,
            Event::Update(Count {
                value: 2,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            })
        );

        // Send the `Update` event back to the app.
        let mut cmd = app.update(event, &mut model);

        // The app should ask the shell to render.
        assert_effect!(cmd, Effect::Render(_));

        // The model should be updated.
        insta::assert_yaml_snapshot!(model, @r#"
        count:
          value: 2
          updated_at: "2023-01-01T00:00:00Z"
        "#);
    }

    /// Test that a `Decrement` event causes the app to decrement the counter
    #[test]
    fn decrement_counter() {
        let app = Counter;

        // set up our initial model as though we've previously fetched the counter
        let mut model = Model {
            count: Count {
                value: 0,
                updated_at: Some(Utc.with_ymd_and_hms(2022, 12, 31, 23, 59, 0).unwrap()),
            },
        };

        // Send a `Decrement` event to the app
        let mut update = app.update(Event::Decrement, &mut model);

        // The app should ask the shell to render the optimistic update
        assert_effect!(update, Effect::Render(_));

        // And send an HTTP post
        let mut request = update.effects().next().unwrap().expect_http();
        assert_eq!(
            &request.operation,
            &HttpRequest::post("https://crux-counter.fly.dev/dec").build()
        );

        // We are expecting our model to be updated "optimistically" before the
        // HTTP request completes, so the value should have been updated
        // but not the timestamp
        assert_eq!(
            model.count,
            Count {
                value: -1,
                updated_at: None
            }
        );

        // Resolve the request with a simulated response from the web API
        request
            .resolve(HttpResult::Ok(
                HttpResponse::ok()
                    .body(r#"{ "value": -1, "updated_at": 1672531200000 }"#)
                    .build(),
            ))
            .unwrap();

        // this should generate a `Set` event
        let event = update.events().next().unwrap();
        assert!(matches!(event, Event::Set(_)));

        // Send the `Set` event back to the app
        let mut update = app.update(event, &mut model);

        // this should generate an `Update` event
        let event = update.events().next().unwrap();
        assert_eq!(
            event,
            Event::Update(Count {
                value: -1,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            })
        );

        // Send the `Update` event back to the app
        let mut update = app.update(event, &mut model);

        // The app should ask the shell to render
        assert_effect!(update, Effect::Render(_));

        // the model should be updated
        insta::assert_yaml_snapshot!(model, @r#"
        count:
          value: -1
          updated_at: "2023-01-01T00:00:00Z"
        "#);
    }

    #[test]
    fn server_sent_events() {
        let app = Counter;
        let mut model = Model::default();

        // Start an SSE subscription to watch for updates from the server
        let mut cmd = app.update(Event::StartWatch, &mut model);

        // The app should request a Server-Sent Events stream
        let mut request = cmd.effects().next().unwrap().expect_server_sent_events();
        assert_eq!(
            request.operation,
            SseRequest {
                url: "https://crux-counter.fly.dev/sse".to_string(),
            }
        );

        // Resolve the request with a simulated response from the web API
        request
            .resolve(SseResponse::Chunk(
                br#"data: {"value":1,"updated_at":1672531200000}

                    "#
                .to_vec(),
            ))
            .unwrap();

        // The app should emit an `Update` event with the new `Count`
        let event = cmd.events().next().unwrap();
        assert_eq!(
            event,
            Event::Update(Count {
                value: 1,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            })
        );

        // We can resolve the request with another simulated response
        request
            .resolve(SseResponse::Chunk(
                br#"data: {"value":2,"updated_at":1672531200000}

                    "#
                .to_vec(),
            ))
            .unwrap();

        // The app should emit another `Update` event with the new `Count`
        let event = cmd.events().next().unwrap();
        assert_eq!(
            event,
            Event::Update(Count {
                value: 2,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            })
        );
    }
}
